#+TITLE: Readme

* Introduction

Compile NML2 definitions to Arbor NMODL. The ~nmlcc~ tool will consume a list of
LEMS files containing NML2 conformant ~ComponentType~ definitions and a NeuroML2
file (~.nml~). By default the following definitions are used
- NML2 :: =development= branch; XSD ~v2.2~
- LEMS :: =development= branch; XSD ~v0.7.6~

* Getting Started

Install a recent version of the Rust language, using =rustup= or your favourite
package manager.

Clone this repo and try an example
#+begin_src shell
git clone git@github.com:thorstenhater/nmlcc.git
cd nmlcc
cargo run -- nmodl --type ionChannelHH example/nml-simple-ion-channels.xml
#+end_src
This will build the =nmlcc= compiler and all its dependencies, which can take
a bit. The final output should be a file ~NaConductance.mod~ in the current
directory.

* Usage

*Note* we use =nmlcc= as if calling the tool directly, when using =cargo=,
  replace =nmlcc= with =cargo run -- [args]= instead.

** Generate =NMODL= from NeuroML2 Dynamics

=nmlcc nmodl <options> <input.nml>= generates NMODL files that can be compiled
into Arbor catalogues. Files will be written to =<id>.mod= in the current
directory where =<id>= is the nml2 component id.

*** Options
- =--type=<ct>= :: (required) will choose a =ComponentType= named =ct= from
  which the =.mod= files will be built. If multiple instances are found, one
  NMODL file is written per instance.
- =--parameter=+p,-q,..= :: will choose parameters to retain as tweakable
  - =-q= excludes parameter =q= from the final list, unless overridden
  - =+p= similarly, will add =p=
  - a selector can _end_ on wildcard =*= to select all suffixes
    - a wildcard anywhere else will be considered a literal =*= character
    - wildcards must be ordered from least to most specific, ie =foo_bar_*= must
      come _after_ =foo_*= to have effect
  - if not given, all will be retained (default =+*=)
  - when compiling channels derived from the following base types, we will alter
    the parameter list slightly in order to play nicely with export to ACC
    - =baseIonChannel= :: =+conductance=, if non-specific currents are used
      =+conductance,+e=
    - =baseVoltageDepSynapse= :: =+gbase,+erev=
    - =gapJunction= :: =+weight,+conductance=

*** Example: Export a Simple Exponential Synapse

#+begin_src shell
$> nmlcc nmodl --type=gapJunction --parameter='-*' example/nml-gap-junction.xml
$> cat gj1.mod
NEURON {
  SUFFIX gj1
  NONSPECIFIC_CURRENT i
  RANGE weight, conductance
}

PARAMETER {
  weight = 1
  conductance = 0.00000001 (mS)
}

BREAKPOINT {
  i = conductance * weight * (v_peer + -1 * v)
}
#+end_src

** Exporting Cells to Arbor Cable Cell Format (=ACC=)

=nmlcc acc <options> <input.nml>= extracts a Arbor Cable Cell description based on the
  =biophysicalProperties=

*** Options
- =--cell=<id>= :: (required) selects a cell for export

*** Example: Fetch Parameter Assignments from a Simple Cell Model

#+begin_src shell
$> nmlcc acc --cell=hhcell example/nml-hh-cell.nml
$> cat hhcell.acc
(arbor-component
  (meta-data (version "0.1-dev"))
  (decor
    (paint (region "all") (density (mechanism "passiveChan" ("e" -54.387001037597656) ("conductance" 0.30000001192092896))))
    (default (ion-reversal-potential "na" 50))
    (paint (region "all") (density (mechanism "naChan" ("conductance" 120))))
    (default (ion-reversal-potential "k" -77))
    (paint (region "all") (density (mechanism "kChan" ("conductance" 36))))
    (default (membrane-capacitance 1))
    (default (membrane-potential -65.4000015258789))
    (default (axial-resistivity 0.029999999329447746))))
#+end_src

* Current Limitations
- units will not be treated completly, rather upon seeing a quantity, it will be
  converted to a 'blessed' unit for that dimension, eg ~1 m~ will become ~100
  cm~ internally. This can have some consequences for accuracy.
- ACC export is only valid for Arbor =0.6=

* Bootstraping the Compiler

This project comes with a pre-built data model in =src/lems/raw.rs= and
=src/neuroml/raw.rs=. If you change the underlying LEMS/NML2 definitions or edit
=src/schema.rs= you'll need to rebuild the data model by running this command
#+begin_src shell
cargo run --bin schema
#+end_src
This will allow for tweaking the versions of the NML2/LEMS schemata or adjusting
them by hand.

The default state is produced by this script
#+begin_src shell
bash bootstrap.sh
#+end_src
which will
- bring in the LEMS and NML2 schemata
- (and *remove them* if present)
- slightly modify both of them
- build the data model from the schemata

Afterwards, you will need to re-compile the =nmlcc= binary (=cargo build= or
=cargo run=).
